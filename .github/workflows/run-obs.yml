name: Update OBS Packages

on:
  workflow_dispatch:
    inputs:
      package:
        description: "Package(s) to update: single (niri-git), multiple space-separated (niri-git quickshell-git), or 'all'"
        required: false
        default: "all"
      rebuild_release:
        description: "Release number for rebuilds (e.g., 2, 3, 4 to increment spec Release)"
        required: false
        default: ""
  schedule:
    - cron: "0 */6 * * *" # Every 6 hours (00:00, 06:00, 12:00, 18:00 UTC)

jobs:
  check-updates:
    name: Check for updates
    runs-on: ubuntu-latest

    outputs:
      has_updates: ${{ steps.check.outputs.has_updates }}
      packages: ${{ steps.check.outputs.packages }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

          # Install yq for reading pins.yaml
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Check for updates
        id: check
        env:
          OBS_USERNAME: ${{ secrets.OBS_USERNAME }}
          OBS_PASSWORD: ${{ secrets.OBS_PASSWORD }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Helper function to get latest version from GitHub
          get_github_version() {
            local repo="$1"
            local current_version=$(curl -s "https://api.github.com/repos/$repo/releases/latest" | grep '"tag_name"' | sed 's/.*"tag_name": "v\?\([^"]*\)".*/\1/')
            echo "$current_version"
          }

          # Helper function to check OBS version via API
          check_obs_version() {
            local package="$1"
            local obs_spec=$(curl -s -u "$OBS_USERNAME:$OBS_PASSWORD" "https://api.opensuse.org/source/home:AvengeMedia:danklinux/$package/$package.spec" 2>/dev/null || echo "")

            if [[ -n "$obs_spec" && "$obs_spec" == *"Version:"* ]]; then
              local obs_version=$(echo "$obs_spec" | grep "^Version:" | awk '{print $2}' | xargs)
              echo "$obs_version"
            else
              echo ""
            fi
          }

          # Helper function to get latest GitHub release version
          get_github_latest_version() {
            local repo="$1"
            local version=$(curl -s "https://api.github.com/repos/$repo/releases/latest" | grep '"tag_name"' | sed 's/.*"tag_name": "v\?\([^"]*\)".*/\1/' || echo "")
            echo "$version"
          }

          # Helper function to extract git commit from changelog
          get_changelog_commit() {
            local package="$1"
            local changelog_file="distro/debian/$package/debian/changelog"

            if [[ ! -f "$changelog_file" ]]; then
              echo ""
              return 1
            fi

            # Extract commit hash (8 chars) from version like "niri-git (25.11+git2576.7c089857.db1-1)" or "(25.11+git2576.7c089857db1)"
            local commit=$(grep -m1 "^$package" "$changelog_file" | grep -oP '\+git\d+\.\K[a-f0-9]{8}(?=\.?db|\)|\.)' || echo "")
            echo "$commit"
          }

          # Helper function to get latest upstream commit for git packages
          get_latest_git_commit() {
            local repo="$1"

            # First, get the default branch (use -L to follow redirects for moved repos)
            local default_branch=$(curl -sL "https://api.github.com/repos/$repo" | grep -oP '"default_branch":\s*"\K[^"]+' || echo "master")

            # Get the latest commit SHA from the default branch (first 8 chars, -L to follow redirects)
            local commit=$(curl -sL "https://api.github.com/repos/$repo/commits/$default_branch" | grep -oP '"sha":\s*"\K[a-f0-9]{40}' | head -c 8 || echo "")
            echo "$commit"
          }

          # Helper function to check if package needs update
          needs_update() {
            local package="$1"
            local spec_file="distro/opensuse/$package.spec"

            if [[ ! -f "$spec_file" ]]; then
              echo "âš ï¸  $package: No spec file found"
              return 1
            fi

            # Get OBS version via API
            local obs_version=$(check_obs_version "$package")

            if [[ -z "$obs_version" ]]; then
              echo "ðŸ“‹ $package: Not found on OBS (new package)"
              return 0  # New package, needs upload
            fi

            # For -git packages, check upstream commit
            if [[ "$package" == *"-git" ]]; then
              local upstream_repo=""
              case "$package" in
                niri-git)
                  upstream_repo="YaLTeR/niri"
                  ;;
                quickshell-git)
                  upstream_repo="outfoxxed/quickshell"
                  ;;
                xwayland-satellite-git)
                  upstream_repo="Supreeeme/xwayland-satellite"
                  ;;
                *)
                  echo "âš ï¸  $package: No upstream repo configured for git package"
                  return 1
                  ;;
              esac

              # Get current commit from changelog
              local current_commit=$(get_changelog_commit "$package")
              if [[ -z "$current_commit" ]]; then
                echo "ðŸ“‹ $package: No changelog found (new package)"
                return 0  # New package, needs upload
              fi

              # Get latest upstream commit
              local latest_commit=$(get_latest_git_commit "$upstream_repo")
              if [[ -z "$latest_commit" ]]; then
                echo "âš ï¸  $package: Failed to fetch upstream commit"
                return 1
              fi

              # Compare commits
              if [[ "$current_commit" != "$latest_commit" ]]; then
                echo "ðŸ“‹ $package: New commit $latest_commit (current: $current_commit)"
                return 0  # Update needed
              fi

              echo "ðŸ“‹ $package: Commit $current_commit already up to date"
              return 1  # No update needed
            fi

            # For stable packages, check upstream GitHub releases
            local upstream_version=""
            case "$package" in
              danksearch)
                upstream_version=$(get_github_latest_version "AvengeMedia/DankSearch")
                ;;
              dgop)
                upstream_version=$(get_github_latest_version "AvengeMedia/DGoP")
                ;;
              ghostty)
                upstream_version=$(get_github_latest_version "ghostty-org/ghostty")
                ;;
              cliphist)
                upstream_version=$(get_github_latest_version "sentriz/cliphist")
                ;;
              matugen)
                upstream_version=$(get_github_latest_version "InioX/matugen")
                ;;
              niri)
                upstream_version=$(get_github_latest_version "YaLTeR/niri")
                ;;
              quickshell)
                upstream_version=$(get_github_latest_version "outfoxxed/quickshell")
                ;;
              xwayland-satellite)
                upstream_version=$(get_github_latest_version "Supreeeme/xwayland-satellite")
                ;;
              *)
                # Unknown package - skip (no upstream source configured)
                echo "âš ï¸  $package: No upstream source configured, skipping version check"
                return 1
                ;;
            esac

            # Strip db suffix from OBS version for comparison
            local obs_version_clean=$(echo "$obs_version" | sed 's/db[0-9]*$//')

            if [[ -n "$upstream_version" && "$upstream_version" != "$obs_version_clean" ]]; then
              echo "ðŸ“‹ $package: New version $upstream_version (OBS has $obs_version_clean)"
              return 0  # Update needed
            fi

            echo "ðŸ“‹ $package: Version $upstream_version already on OBS"
            return 1  # No update needed
          }

          # Main logic
          REBUILD="${{ github.event.inputs.rebuild_release }}"
          MANUAL_PKG="${{ github.event.inputs.package }}"

          if [[ -n "$REBUILD" ]]; then
            # Rebuild requested - always proceed with specified package(s)
            if [[ "$MANUAL_PKG" == "all" || -z "$MANUAL_PKG" ]]; then
              echo "packages=all" >> $GITHUB_OUTPUT
            else
              echo "packages=$MANUAL_PKG" >> $GITHUB_OUTPUT
            fi
            echo "has_updates=true" >> $GITHUB_OUTPUT
            echo "ðŸ”„ Manual rebuild requested: $MANUAL_PKG (db$REBUILD)"

          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            # Scheduled run - check git packages only
            PACKAGES_TO_UPDATE=()

            for pkg in niri-git quickshell-git xwayland-satellite-git; do
              if needs_update "$pkg"; then
                PACKAGES_TO_UPDATE+=("$pkg")
              fi
            done

            if [[ ${#PACKAGES_TO_UPDATE[@]} -gt 0 ]]; then
              echo "packages=${PACKAGES_TO_UPDATE[*]}" >> $GITHUB_OUTPUT
              echo "has_updates=true" >> $GITHUB_OUTPUT
              echo "âœ“ Git packages to update: ${PACKAGES_TO_UPDATE[*]}"
            else
              echo "packages=" >> $GITHUB_OUTPUT
              echo "has_updates=false" >> $GITHUB_OUTPUT
              echo "âœ“ All git packages up to date"
            fi

          elif [[ -n "$MANUAL_PKG" ]]; then
            # Manual workflow trigger
            if [[ "$MANUAL_PKG" == "all" ]]; then
              # Check all packages
              PACKAGES_TO_UPDATE=()
              ALL_PACKAGES=(cliphist ghostty matugen niri niri-git quickshell quickshell-git xwayland-satellite xwayland-satellite-git danksearch dgop)

              for pkg in "${ALL_PACKAGES[@]}"; do
                if needs_update "$pkg"; then
                  PACKAGES_TO_UPDATE+=("$pkg")
                fi
              done

              if [[ ${#PACKAGES_TO_UPDATE[@]} -gt 0 ]]; then
                echo "packages=${PACKAGES_TO_UPDATE[*]}" >> $GITHUB_OUTPUT
                echo "has_updates=true" >> $GITHUB_OUTPUT
                echo "âœ“ Packages to update: ${PACKAGES_TO_UPDATE[*]}"
              else
                echo "packages=" >> $GITHUB_OUTPUT
                echo "has_updates=false" >> $GITHUB_OUTPUT
                echo "âœ“ All packages up to date"
              fi
            else
              # Check specific package(s) - can be space-separated list
              PACKAGES_TO_UPDATE=()
              for pkg in $MANUAL_PKG; do
                if needs_update "$pkg"; then
                  PACKAGES_TO_UPDATE+=("$pkg")
                fi
              done

              if [[ ${#PACKAGES_TO_UPDATE[@]} -gt 0 ]]; then
                echo "packages=${PACKAGES_TO_UPDATE[*]}" >> $GITHUB_OUTPUT
                echo "has_updates=true" >> $GITHUB_OUTPUT
                echo "âœ“ Packages to update: ${PACKAGES_TO_UPDATE[*]}"
              else
                echo "packages=" >> $GITHUB_OUTPUT
                echo "has_updates=false" >> $GITHUB_OUTPUT
                echo "âœ“ All specified packages up to date"
              fi
            fi
          else
            # Fallback
            echo "packages=" >> $GITHUB_OUTPUT
            echo "has_updates=false" >> $GITHUB_OUTPUT
          fi

  update-obs:
    name: Upload to OBS
    needs: check-updates
    runs-on: ubuntu-latest
    if: needs.check-updates.outputs.has_updates == 'true'

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine packages to update
        id: packages
        run: |
          PACKAGES="${{ needs.check-updates.outputs.packages }}"

          if [[ -z "$PACKAGES" ]]; then
            echo "âœ“ No packages need uploading. All up to date!"
            echo "packages=" >> $GITHUB_OUTPUT
          else
            echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
            echo "Packages to upload: $PACKAGES"
          fi

      - name: Update git package versions dynamically
        run: |
          # Helper function to update git package spec and changelog
          update_git_package() {
            local package="$1"
            local repo="$2"

            # Get default branch and latest commit
            local default_branch=$(curl -sL "https://api.github.com/repos/$repo" | grep -oP '"default_branch":\s*"\K[^"]+' || echo "master")
            local commit_hash=$(curl -sL "https://api.github.com/repos/$repo/commits/$default_branch" | grep -oP '"sha":\s*"\K[a-f0-9]{40}' | head -c 8 || echo "")

            if [[ -z "$commit_hash" ]]; then
              echo "âš ï¸  Failed to fetch commit for $package from $repo"
              return 1
            fi

            # Get commit count and base version
            local temp_dir=$(mktemp -d)
            git clone --bare "https://github.com/$repo.git" "$temp_dir/$package-repo" 2>/dev/null
            local commit_count=$(git -C "$temp_dir/$package-repo" rev-list --count HEAD || echo "0")
            rm -rf "$temp_dir"

            # Determine base version from the stable package changelog or use a default
            local base_version=""
            case "$package" in
              niri-git)
                base_version=$(grep -m1 "^niri" distro/debian/niri/debian/changelog 2>/dev/null | grep -oP '\(\K[0-9.]+(?=db)' || echo "25.11")
                ;;
              quickshell-git)
                base_version=$(grep -m1 "^quickshell" distro/debian/quickshell/debian/changelog 2>/dev/null | grep -oP '\(\K[0-9.]+(?=db)' || echo "0.2.1")
                ;;
              xwayland-satellite-git)
                base_version=$(grep -m1 "^xwayland-satellite" distro/debian/xwayland-satellite/debian/changelog 2>/dev/null | grep -oP '\(\K[0-9.]+(?=db)' || echo "0.8")
                ;;
            esac

            local new_version="${base_version}+git${commit_count}.${commit_hash}"
            echo "ðŸ“¦ Updating $package to version: $new_version"

            # Update OpenSUSE spec file if it exists
            if [[ -f "distro/opensuse/${package}.spec" ]]; then
              sed -i "s/^Version:.*/Version:        $new_version/" "distro/opensuse/${package}.spec"
              echo "  âœ“ Updated distro/opensuse/${package}.spec"
            fi

            # Update Debian changelog
            if [[ -f "distro/debian/${package}/debian/changelog" ]]; then
              local changelog_date=$(date -R)
              {
                echo "${package} (${new_version}db1) unstable; urgency=medium"
                echo ""
                echo "  * Git snapshot (commit $commit_count: $commit_hash)"
                echo ""
                echo " -- Avenge Media <AvengeMedia.US@gmail.com>  $changelog_date"
              } > "distro/debian/${package}/debian/changelog"
              echo "  âœ“ Updated distro/debian/${package}/debian/changelog"
            fi
          }

          # Update each git package that needs updating
          for pkg in ${{ steps.packages.outputs.packages }}; do
            case "$pkg" in
              niri-git)
                update_git_package "niri-git" "YaLTeR/niri"
                ;;
              quickshell-git)
                update_git_package "quickshell-git" "outfoxxed/quickshell"
                ;;
              xwayland-satellite-git)
                update_git_package "xwayland-satellite-git" "Supreeeme/xwayland-satellite"
                ;;
            esac
          done

      - name: Update spec files with latest versions
        run: |
          # Helper function to get latest version from GitHub
          get_latest_version() {
            local repo="$1"
            curl -s "https://api.github.com/repos/$repo/releases/latest" | grep '"tag_name"' | sed 's/.*"tag_name": "v\?\([^"]*\)".*/\1/' || echo ""
          }

          # Update spec files for packages that need updates
          for pkg in ${{ steps.packages.outputs.packages }}; do
            case "$pkg" in
              danksearch)
                VERSION=$(get_latest_version "AvengeMedia/DankSearch")
                if [[ -n "$VERSION" ]]; then
                  echo "ðŸ“¦ Updating danksearch to version: $VERSION"
                  [[ -f distro/opensuse/danksearch.spec ]] && sed -i "s/^Version:.*/Version:        $VERSION/" distro/opensuse/danksearch.spec
                  [[ -f distro/debian/danksearch/debian/changelog ]] && sed -i "1s/danksearch ([^)]*/danksearch (${VERSION}.db1/" distro/debian/danksearch/debian/changelog
                fi
                ;;
              dgop)
                VERSION=$(get_latest_version "AvengeMedia/DGoP")
                if [[ -n "$VERSION" ]]; then
                  echo "ðŸ“¦ Updating dgop to version: $VERSION"
                  [[ -f distro/opensuse/dgop.spec ]] && sed -i "s/^Version:.*/Version:        $VERSION/" distro/opensuse/dgop.spec
                  [[ -f distro/debian/dgop/debian/changelog ]] && sed -i "1s/dgop ([^)]*/dgop (${VERSION}.db1/" distro/debian/dgop/debian/changelog
                fi
                ;;
              ghostty)
                VERSION=$(get_latest_version "ghostty-org/ghostty")
                if [[ -n "$VERSION" ]]; then
                  echo "ðŸ“¦ Updating ghostty to version: $VERSION"
                  [[ -f distro/opensuse/ghostty.spec ]] && sed -i "s/^Version:.*/Version:        $VERSION/" distro/opensuse/ghostty.spec
                  [[ -f distro/debian/ghostty/debian/changelog ]] && sed -i "1s/ghostty ([^)]*/ghostty (${VERSION}.db1/" distro/debian/ghostty/debian/changelog
                fi
                ;;
              cliphist)
                VERSION=$(get_latest_version "sentriz/cliphist")
                if [[ -n "$VERSION" ]]; then
                  echo "ðŸ“¦ Updating cliphist to version: $VERSION"
                  [[ -f distro/opensuse/cliphist.spec ]] && sed -i "s/^Version:.*/Version:        $VERSION/" distro/opensuse/cliphist.spec
                  [[ -f distro/debian/cliphist/debian/changelog ]] && sed -i "1s/cliphist ([^)]*/cliphist (${VERSION}.db1/" distro/debian/cliphist/debian/changelog
                fi
                ;;
              matugen)
                VERSION=$(get_latest_version "InioX/matugen")
                if [[ -n "$VERSION" ]]; then
                  echo "ðŸ“¦ Updating matugen to version: $VERSION"
                  [[ -f distro/opensuse/matugen.spec ]] && sed -i "s/^Version:.*/Version:        $VERSION/" distro/opensuse/matugen.spec
                  [[ -f distro/debian/matugen/debian/changelog ]] && sed -i "1s/matugen ([^)]*/matugen (${VERSION}.db1/" distro/debian/matugen/debian/changelog
                fi
                ;;
              niri)
                # niri stable only exists for Debian, not OpenSUSE (only niri-git exists for OpenSUSE)
                VERSION=$(get_latest_version "YaLTeR/niri")
                if [[ -n "$VERSION" ]]; then
                  echo "ðŸ“¦ Updating niri to version: $VERSION (Debian only - OpenSUSE uses niri-git)"
                  [[ -f distro/debian/niri/debian/changelog ]] && sed -i "1s/niri ([^)]*/niri (${VERSION}.db1/" distro/debian/niri/debian/changelog
                fi
                ;;
              quickshell)
                VERSION=$(get_latest_version "outfoxxed/quickshell")
                if [[ -n "$VERSION" ]]; then
                  echo "ðŸ“¦ Updating quickshell to version: $VERSION"
                  [[ -f distro/opensuse/quickshell.spec ]] && sed -i "s/^Version:.*/Version:        $VERSION/" distro/opensuse/quickshell.spec
                  [[ -f distro/debian/quickshell/debian/changelog ]] && sed -i "1s/quickshell ([^)]*/quickshell (${VERSION}.db1/" distro/debian/quickshell/debian/changelog
                fi
                ;;
              xwayland-satellite)
                VERSION=$(get_latest_version "Supreeeme/xwayland-satellite")
                if [[ -n "$VERSION" ]]; then
                  echo "ðŸ“¦ Updating xwayland-satellite to version: $VERSION"
                  [[ -f distro/opensuse/xwayland-satellite.spec ]] && sed -i "s/^Version:.*/Version:        $VERSION/" distro/opensuse/xwayland-satellite.spec
                  [[ -f distro/debian/xwayland-satellite/debian/changelog ]] && sed -i "1s/xwayland-satellite ([^)]*/xwayland-satellite (${VERSION}.db1/" distro/debian/xwayland-satellite/debian/changelog
                fi
                ;;
              *-git)
                # Git packages are handled by obs-upload.sh (clones upstream repos)
                echo "â­ï¸  Skipping $pkg - git packages fetch versions dynamically"
                ;;
            esac
          done

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y osc

          mkdir -p ~/.config/osc
          cat > ~/.config/osc/oscrc << EOF
          [general]
          apiurl = https://api.opensuse.org

          [https://api.opensuse.org]
          user = ${{ secrets.OBS_USERNAME }}
          pass = ${{ secrets.OBS_PASSWORD }}
          EOF
          chmod 600 ~/.config/osc/oscrc

      - name: Install Go (for Go packages)
        if: contains(steps.packages.outputs.packages, 'cliphist') || contains(steps.packages.outputs.packages, 'dgop')
        uses: actions/setup-go@v5
        with:
          go-version: "1.24"

      - name: Install Rust (for Rust packages)
        if: |
          contains(steps.packages.outputs.packages, 'niri') ||
          contains(steps.packages.outputs.packages, 'xwayland-satellite') ||
          contains(steps.packages.outputs.packages, 'matugen')
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable

      - name: Upload to OBS
        env:
          REBUILD_RELEASE: ${{ github.event.inputs.rebuild_release }}
        run: |
          PACKAGES="${{ steps.packages.outputs.packages }}"

          if [[ -z "$PACKAGES" ]]; then
            echo "âœ“ No packages need uploading. All up to date!"
            exit 0
          fi

          MESSAGE="Automated update from GitHub Actions"

          # PACKAGES can be space-separated list (e.g., "niri-git quickshell-git" from "all" check)
          # Loop through each package and upload
          for PKG in $PACKAGES; do
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "Uploading $PKG to OBS..."
            if [[ -n "$REBUILD_RELEASE" ]]; then
              echo "ðŸ”„ Using rebuild release number: db$REBUILD_RELEASE"
            fi
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

            if [[ -n "$REBUILD_RELEASE" ]]; then
              bash distro/scripts/obs-upload.sh "$PKG" "$MESSAGE" "$REBUILD_RELEASE"
            else
              bash distro/scripts/obs-upload.sh "$PKG" "$MESSAGE"
            fi
          done

      - name: Summary
        if: always()
        run: |
          echo "### OBS Package Upload Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          PACKAGES="${{ steps.packages.outputs.packages }}"

          if [[ -z "$PACKAGES" ]]; then
            echo "**Status:** âœ… All packages up to date (no uploads needed)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All packages are current. Run completed successfully." >> $GITHUB_STEP_SUMMARY
          else
            echo "**Packages Uploaded:**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            for PKG in $PACKAGES; do
              echo "- âœ… **$PKG** â†’ [View builds](https://build.opensuse.org/package/show/home:AvengeMedia:danklinux/$PKG)" >> $GITHUB_STEP_SUMMARY
            done

            echo "" >> $GITHUB_STEP_SUMMARY

            if [[ -n "${{ github.event.inputs.rebuild_release }}" ]]; then
              echo "**Rebuild Number:** db${{ github.event.inputs.rebuild_release }}" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi

            echo "Monitor build progress on [OBS project page](https://build.opensuse.org/project/show/home:AvengeMedia:danklinux)." >> $GITHUB_STEP_SUMMARY
          fi
